from datetime import datetime
from random import randint
from time import time
import logging
import brotli
import json
import re

log = logging.getLogger(__name__)

class Location:

    def __init__(self, login, session, path, config, person, debug):

        self.session = session
        self.config = config
        self.debug = debug

        self.raw_output = None
        self.raw_people = None
        self.new_people = {}
        self.old_people = {}
        self.person_class = person
        self.people = []

        self.location_debug = path / 'debug/location_debug'

        self.headers = {'authority': self.config['header_authority'],
                        'accept-language': 'en-US,en;q=0.9',
                        'accept-encoding': 'gzip, deflate, br',
                        'accept': 'application/json, text/plain, */*',
                        'referer': self.config['header_referer'],
                        'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36'}
        self.payload = {'gl': 'us',
                        'authuser': login,
                        'hl': 'en',
                        'pb': '!1e1!2m2!1sp-PDW8CZOKj_0gKPorqABQ!7e81!3m2!1s107699590211062977112!2s'}

    def query_data(self):
        '''
        uses session from cookie to query google maps location sharing.
        response decompressed via brotli and stored to self.raw_output.
        '''

        try:
            log.debug('Query - Requesting location data.')
            response = self.session.get(self.config['sharing_url'], params=self.payload, headers=self.headers)
            log.debug('Query - Decompressing and decoding response.')
            self.raw_output = brotli.decompress(response.content).decode('utf-8')
            return True
        except Exception as e:
            log.debug('Query Error - {}'.format(e))
            if self.debug:
                try:
                    data = response.content
                except:
                    data = 'N/A'
                log.debug('Dumping response.content output if available.')
                self.debug_output(e, 'query_data', data)
            return False

    def parse_raw_output(self):
        '''
        Input: self.raw_output from query_data.
        Performs: data filtration. splits output into raw groups, drops trash
                  rows from from each person. creates list of dicts for each
                  person with key:value using useful raw data labels and value
                  lines.
        Returns: list of raw user dictionaries
        '''

        try:
            raw_output = self.raw_output.split('[[')[2:]
            keep_rows = [1, 3, 5, 8, 9, 11, 22]
            ro_dict = { 1:'id',3:'photo',5:'full_name',8:'gps',
                        9:'address',11:'country',22:'battery'}
            raw_people = []

            for person in raw_output:
                raw_person = {}
                for i, p in enumerate(person.split('"'), 0):
                    if i in keep_rows:
                        key = ro_dict[i]
                        raw_person[key] = p
                raw_people.append(raw_person)
            if len(raw_people) > 0:
                self.raw_people = raw_people
                return True
        except Exception as e:
            log.debug('Parse raw output Error - {}.'.format(e))
            if self.debug:
                log.debug('Dumping raw output to debug.')
                self.debug_output(e, 'parse_raw_output', self.raw_output)
            return False

    def parse_raw_people(self):
        '''
        Input: self.raw_output list
        Performs: final cleanup of per person raw_output into dictionary of
                  people using id:person as first level keys with key:value per
                  person. regex and error catching for gps, battery, and scenarios
                  where phone is on battery optimization mode.
        Returns: new_people dict containing {person_id:{key:value}}
        '''

        re_gps = re.compile('([-0-9]+.[0-9]+),([-0-9]+.[0-9]+)],([0-9]+),([0-9]+)')
        re_battery = re.compile('^.*\[([0-1]{1}),([0-9]{1,3})')

        new_people = {}
        for person in self.raw_people:
            id = person['id']
            name = person['full_name'].split()[0]
            new_people[id] = {'gps':{}, 'battery':{}}
            for key, value in person.items():
                value = value.replace('\n', '')
                if key == 'id':
                    log.debug('Setting {} for {}.'.format(key, name))
                    new_people[id][key] = int(value)
                elif key == 'photo':
                    log.debug('Setting {} for {}.'.format(key, name))
                    new_people[id][key] = value
                elif key == 'full_name':
                    log.debug('Setting {} for {}.'.format(key, name))
                    new_people[id][key] = value
                    new_people[id]['first_name'] = value.split()[0]
                elif key == 'gps':
                    try:
                        log.debug('Setting lat, lon, accuracy, and last seen for {}.'.format(name))
                        gps = re_gps.search(value).group(1,2,3,4)
                        new_people[id][key]['latitude'] = gps[1]
                        new_people[id][key]['longitude'] = gps[0]
                        new_people[id][key]['accuracy'] = int(gps[3])
                        new_people[id]['last_seen'] = int(gps[2]) / 1000
                    except Exception as e:
                        log.warning('Bad or missing {} data for {}.'.format(key, name))
                        if self.debug:
                            log.debug('Dumping gps output to debug.')
                            source = 'parse_raw_people - {}'.format(name)
                            self.debug_output(e, source, value)
                        log.debug('Setting {} to None for {}.'.format(key, name))
                        # Set latitude & longitude to None
                        # Set accuracy outside default ignore range
                        new_people[id][key]['latitude'] = None
                        new_people[id][key]['longitude'] = None
                        new_people[id][key]['accuracy'] = None
                        new_people[id]['last_seen'] = time()
                elif key == 'address':
                    if ' ' in value:
                        try:
                            log.debug('Setting {} for {}.'.format(key, name))
                            new_people[id][key] = value
                        except Exception as e:
                            log.warning('Bad or missing {} data for {}.'.format(key, name))
                            if self.debug:
                                log.debug('Dumping address output to debug.')
                                source = 'parse_raw_people - {}'.format(name)
                                self.debug_output(e, source, value)
                            log.debug('Setting {} to None for {}.'.format(key, name))
                            new_people[id][key] = None
                elif key == 'country':
                    if value.isalpha() and value.isupper():
                        log.debug('Setting {} for {}.'.format(key, name))
                        new_people[id][key] = value
                    else:
                        log.warning('Bad or missing {} data for {}.'.format(key, name))
                        log.debug('Setting {} to None for {}.'.format(key, name))
                        if self.debug:
                            log.debug('Dumping country output to debug.')
                            source = 'parse_raw_people - {}'.format(name)
                            self.debug_output(e, source, value)
                        new_people[id][key] = None
                elif key == 'battery':
                    try:
                        log.debug('Setting {} for {}.'.format(key, name))
                        battery = re_battery.search(value).group(1,2)
                        new_people[id][key]['charging'] = True if battery[0] == 1 else False
                        new_people[id][key]['level'] = int(battery[1])
                    except Exception as e:
                        log.warning('Bad or missing {} data for {}.'.format(key, name))
                        log.debug('Setting {} to None for {}.'.format(key, name))
                        if self.debug:
                            log.debug('Dumping battery output to debug.')
                            source = 'parse_raw_people - {}'.format(name)
                            self.debug_output(e, source, value)
                        new_people[id][key]['charging'] = False
                        new_people[id][key]['level'] = None
        if len(new_people.keys()) > 0:
            self.new_people = new_people
            return True
        return False

    def update_people(self):
        '''
        Input: dicts from new_people and old_people.
        Performs: additions/deletions to location sharing users and update
                  old_people dict with new values for each person, if they are
                  not null/none and different from existing data.
        Returns: updated old_people dict.
        '''

        np = self.new_people
        op = self.old_people if len(self.old_people.keys()) > 0 else {}

        if len(op.keys()) == 0:
            log.debug('Copying new_people to old_people on first run.')
            op = np
        else:
            if np.keys() != op.keys():
                add = [id for id in np.keys() if len(np.keys()) > 0 and id not in op.keys()]
                remove = [id for id in op.keys() if len(op.keys()) > 0 and id not in np.keys()]
                if len(add) != 0:
                    log.debug('IDs to add: {}'.format(add))
                if len(remove) != 0:
                    log.debug('IDs to remove: {}'.format(remove))
                for id in add:
                    log.debug('Adding {}:{} to old_people.'.format(id, np[id]))
                    op[id] = np[id]
                for id in remove:
                    log.debug('Deleting {}:{} from old_people.'.format(id, op[id]))
                    del op[id]

            if np.keys() == op.keys():
                log.debug('Comparing new and existing persons.')
                for id, person in np.items():
                    name = person['full_name'].split()[0]
                    for key, value in person.items():
                        if not isinstance(value, dict):
                            new_value = np[id][key]
                            old_value = op[id][key]
                            if new_value != old_value and new_value is not None:
                                log.debug('Updating {} for {} to {}.'.format(key, name, new_value))
                                op[id][key] = np[id][key]
                        elif isinstance(value, dict):
                            for k, v in value.items():
                                nv = np[id][key][k]
                                ov = op[id][key][k]
                                if nv != ov and nv is not None:
                                    log.debug('Updating {}:{} for {} to {}.'.format(key, k, name, nv))
                                    op[id][key][k] = np[id][key][k]
        if len(op.keys()) > 0:
            self.old_people = op
            return True
        return False

    def create_people(self):
        '''
        Inputs: person class entity and old_people dict.
        Performs: conversion of old_people into class entities.
        Returns: people objects to be returned back to HA for consumption.
        '''

        try:
            Person = self.person_class
            people = self.old_people

            log.debug('Create People - Converting location data into Person object.')
            for id, person in people.items():
                self.people.append(Person(person))

            log.debug('Create People - Created {} people.'.format(len(self.people)))
            return True

        except Exception as e:
            log.error('Create People Error - {}'.format(e))
            if self.debug:
                log.debug('Dumping self.old_people to debug.')
                self.debug_output(e, 'create_people', self.old_people)

        return False

    def update(self):
        '''
        Performs: location update for gmapslocsharing.
        '''

        log.debug('Updating location sharing data.')

        self.raw_output = None
        self.raw_people = None
        self.new_people = None
        self.people = []

        try:
            log.debug('Requesting data via browser.')
            if self.query_data():
                log.debug('Parsing raw output.')
                if self.parse_raw_output():
                    log.debug('Parsing raw people.')
                    if self.parse_raw_people():
                        log.debug('Updating people.')
                        if self.update_people():
                            log.debug('Converting people to Person objects.')
                            if self.create_people():
                                log.debug('Location update completed successfully.')

        except Exception as e:
            log.error('Update Failure - {}'.format(e))

    def debug_output(self, exception, function, data):
        '''
        Inputs: exception, function name, pertinent data
        Performs: output to debug location of various types of inputs which
                  caused exceptions for troubleshooting.
        '''

        if not self.location_debug.exists():
            self.location_debug.touch(mode=0o660)

        timestamp = datetime.now().strftime('%Y-%m-%d - %H:%M:%S')

        with open(self.location_debug, mode='a') as f:

            f.write('\n\n[{}][{}]:\n'.format(timestamp, function))
            f.write('Exception:\n{}\n'.format(exception))

            if isinstance(data, list):
                f.write('List Data:\n')
                for item in data:
                    f.write(item)

            elif isinstance(data, dict):
                f.write('Dict Data:\n')
                for key, value in data.items():
                    f.write('Key:\n{}\nValue:\n{}\n'.format(key, value))

            else:
                f.write('Data:\n{}\n'.format(data))
