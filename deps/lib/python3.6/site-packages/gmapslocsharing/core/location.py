from collections import namedtuple
from datetime import datetime
import logging
import json
import os

log = logging.getLogger(__name__)
CHROME_VERSION = os.popen('google-chrome-stable --version').read().split(' ')[2]

class Location:

    def __init__(self, login, session, path, config, debug):

        self.session = session
        self.config = config
        self.debug = debug

        self.dict_people = {}
        self.people = []

        self.location_debug = path / 'debug/location_debug'

        self.headers = {
                        'authority': self.config['header_authority'],
                        'accept-language': 'en-US,en;q=0.9',
                        'scheme': 'https',
                        'accept': '*/*',
                        'accept-encoding': 'gzip, deflate, br',
                        'referer': self.config['header_referer'],
                        'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/{CHROME_VERSION} Safari/537.36'
                        }
        self.payload = {
                        'authuser': login,
                        'hl': 'en',
                        'gl': 'us',
                        'pb': '!1e1!2m2!1s_SU6XdHiHcuW0wLq-qFo!7e81'
                        }

    def query_data(self):
        '''
        uses session from cookie to query google maps location sharing.
        response decompressed via brotli and stored to self.raw_output.
        '''

        try:
            response = self.session.get(self.config['sharing_url'], params=self.payload, headers=self.headers)
            if response.ok:
                return response.content.decode('utf-8')
        except Exception as e:
            log.debug('Query Error - {}'.format(e))
            if self.debug:
                log.debug('Dumping response.content output if available.')
                self.temp_debug(response.content)

    def parse_raw_output(self, raw_output):
        '''
        Input: self.raw_output from query_data.
        Performs: data filtration. splits output into raw groups, drops trash
                  rows from from each person. creates list of dicts for each
                  person with key:value using useful raw data labels and value
                  lines.
        Returns: list of raw user dictionaries
        '''

        raw_people = []

        try:
            raw_output = raw_output.split('[[')[2:]
            for raw_person in raw_output:
                raw_person = raw_person.replace('\'','')
                raw_person = raw_person.replace('\"','')
                raw_person = raw_person.replace('[','')
                raw_person = raw_person.replace(']','')
                raw_person = raw_person.replace('\n', '')
                raw_person = ','.join(  item[:-2] if item.endswith('\\n')
                                        else item for item in raw_person.split(','))
                raw_person = ','.join(item.lstrip() for item in raw_person.split(',')[:37])
                raw_people.append(raw_person)
            return raw_people

        except Exception as e:
            log.debug('Parse raw output Error - {}.'.format(e))
            if self.debug:
                log.debug('Dumping raw output to debug.')
                self.debug_output(e, 'parse_raw_output', raw_people)

    def parse_raw_people(self, raw_people):
        '''
        Input: self.raw_output list
        Performs: final cleanup of per person raw_output into dictionary of
                  people using id:person as first level keys with key:value per
                  person. regex and error catching for gps, battery, and scenarios
                  where phone is on battery optimization mode.
        Returns: new_people dict containing {person_id:{key:value}}
        '''

        parsed_people = []

        len_34 =    {
                    0: 'id',
                    1: 'picture_url',
                    3: 'full_name',
                    10: 'longitude',
                    11: 'latitude',
                    12: 'last_seen',
                    13: 'accuracy',
                    14: 'address_01',
                    26: 'first_name',
                    33: 'battery_charging',
                    34: 'battery_level'
                    }
        len_35 =    {
                    0: 'id',
                    1: 'picture_url',
                    3: 'full_name',
                    10: 'longitude',
                    11: 'latitude',
                    12: 'last_seen',
                    13: 'accuracy',
                    14: 'address_01',
                    15: 'address_02',
                    27: 'first_name',
                    34: 'battery_charging',
                    35: 'battery_level'
                    }
        len_36 =    {
                    0: 'id',
                    1: 'picture_url',
                    3: 'full_name',
                    10: 'longitude',
                    11: 'latitude',
                    12: 'last_seen',
                    13: 'accuracy',
                    14: 'address_01',
                    15: 'address_02',
                    16: 'address_03',
                    28: 'first_name',
                    35: 'battery_charging',
                    36: 'battery_level'
                    }

        for raw_person in raw_people:
            raw_person = raw_person.split(',')

            try:
                charging35 = raw_person[35]
                battery36 = raw_person[36]
                if all([raw_person[18] == 'null', charging35 in ['0','1']]):
                    log.debug('Attempting to apply length 36 mapping.')
                    if battery36.isdecimal():
                        parsed_person = {
                                        len_36[i]: item for i, item
                                        in zip(
                                                range(len(raw_person)),
                                                raw_person
                                                )
                                        if i in len_36.keys()
                                        }
                    elif battery36.endswith('\\n'):
                        parsed_person = {
                                        len_36[i]: item for i, item
                                        in zip(
                                                range(len(raw_person)),
                                                raw_person
                                                )
                                        if all([i in len_36.keys(), i != 36])
                                        }
                        parsed_person['battery_level'] = None
            except:
                log.debug('Assigning length 36 failed.')

            try:
                charging34 = raw_person[34]
                battery35 = raw_person[35]
                if all([raw_person[17] == 'null', charging34 in ['0','1']]):
                    log.debug('Attempting to apply length 35 mapping.')
                    if battery35.isdecimal():
                        parsed_person = {
                                        len_35[i]: item for i, item
                                        in zip(
                                                range(len(raw_person)),
                                                raw_person
                                                )
                                        if i in len_35.keys()
                                        }
                    elif battery35.endswith('\\n'):
                        parsed_person = {
                                        len_35[i]: item for i, item
                                        in zip(
                                                range(len(raw_person)),
                                                raw_person
                                                )
                                        if all([i in len_35.keys(), i != 35])
                                        }
                        parsed_person['battery_level'] = None
            except:
                log.debug('Assigning length 35 failed.')

            try:
                charging33 = raw_person[33]
                battery34 = raw_person[34]
                if all([raw_person[16] == 'null', charging33 in ['0','1']]):
                    log.debug('Attempting to apply length 34 mapping.')
                    if battery34.isdecimal():
                        parsed_person = {
                                        len_34[i]: item for i, item
                                        in zip(
                                                range(len(raw_person)),
                                                raw_person
                                                )
                                        if i in len_34.keys()
                                        }
                    elif battery34.endswith('\\n'):
                        parsed_person = {
                                        len_34[i]: item for i, item
                                        in zip(
                                                range(len(raw_person)),
                                                raw_person
                                                )
                                        if all([i in len_34.keys(), i != 34])
                                        }
                        parsed_person['battery_level'] = None
            except:
                log.debug('Assigning length 34 failed.')

            if len(parsed_person['first_name'].split('-')) > 1:
                parsed_person['first_name'] = parsed_person['first_name'].split('-')[0]
            elif len(parsed_person['first_name'].split(' ')) > 1:
                parsed_person['first_name'] = parsed_person['first_name'].split(' ')[0]

            log.debug('Appending {} to parsed people.'.format(parsed_person['first_name']))
            parsed_people.append(parsed_person)

        log.debug('Returning parsed people.')
        return parsed_people

    def format_parsed_people(self, parsed_people):

        formatted_people = {}

        person_format = {
                        'int': ['last_seen', 'accuracy', 'battery_level'],
                        'float': ['latitude', 'longitude'],
                        'bool': ['battery_charging']
                        }

        parsed_people = {
                        int(parsed_person['id']): parsed_person
                        for parsed_person in parsed_people
                        }

        for id, person in parsed_people.items():
            for key, data in person.items():
                if key in person_format['int']:
                    if data != None:
                        person[key] = int(data)
                elif key in person_format['float']:
                    person[key] = float(data)
                elif key in person_format['bool']:
                    person[key] = bool(data)
            address = ', '.join(data for key, data in person.items() if key.startswith('address'))
            cleanup =   [
                        key for key in person.keys()
                        if all([key.startswith('address'), str(key[-2:]).isdecimal()])
                        ]
            for trash in cleanup:
                del person[trash]
            person['address'] = address

            person['last_seen'] = datetime.fromtimestamp(person['last_seen'] / 10**3)

            formatted_people.update({id: person})

        return formatted_people

    def update_people(self, formatted_people):
        '''
        Input: dicts from new_people and old_people.
        Performs: additions/deletions to location sharing users and update
                  old_people dict with new values for each person, if they are
                  not null/none and different from existing data.
        Returns: updated old_people dict.
        '''

        np = formatted_people
        op = self.dict_people if len(self.dict_people.keys()) > 0 else {}

        if len(op.keys()) == 0:
            log.debug('Copying new_people to old_people on first run.')
            op = np
            return op
        else:
            if np.keys() != op.keys():
                add = [id for id in np.keys() if len(np.keys()) > 0 and id not in op.keys()]
                remove = [id for id in op.keys() if len(op.keys()) > 0 and id not in np.keys()]
                if len(add) != 0:
                    log.debug('IDs to add: {}'.format(add))
                if len(remove) != 0:
                    log.debug('IDs to remove: {}'.format(remove))
                for id in add:
                    log.debug('Adding {}:{} to old_people.'.format(id, np[id]))
                    op[id] = np[id]
                for id in remove:
                    log.debug('Deleting {}:{} from old_people.'.format(id, op[id]))
                    del op[id]

            elif np.keys() == op.keys():
                log.debug('Comparing new and existing person data.')
                for id, person in np.items():
                    name = person['first_name']
                    for key, value in person.items():
                        new_value = np[id][key]
                        old_value = op[id][key]
                        if new_value != old_value and new_value is not None:
                            log.debug('Updating {} for {} to {}.'.format(key, name, new_value))
                            op[id][key] = np[id][key]
        if len(op.keys()) > 0:
            return op

    def create_people(self, dict_people):
        '''
        Inputs: person class entity and old_people dict.
        Performs: conversion of old_people into class entities.
        Returns: people objects to be returned back to HA for consumption.
        '''

        people = []
        for id, person in dict_people.items():
            Person = namedtuple('Person', ' '.join([key for key in person.keys()]))
            people.append(Person(**person))
        return people

    def update(self):
        '''
        Performs: location update for gmapslocsharing.
        '''

        log.debug('Updating location sharing data.')

        query = False
        go_on = True

        try:
            log.debug('Requesting data via browser.')
            raw_output = self.query_data()
            query = True
        except Exception as e:
            log.error('Update - Query Error - {}'.format(e))

        if query:
            try:
                log.debug('Parsing raw output.')
                raw_people = self.parse_raw_output(raw_output)
            except Exception as e:
                log.info(f'Error parsing raw output: {e}.')
                go_on=False

            if go_on:
                try:
                    log.debug('Parsing raw people.')
                    parsed_people = self.parse_raw_people(raw_people)
                except Exception as e:
                    log.info(f'Error parsing raw people: {e}.')
                    go_on=False

            if go_on:
                try:
                    log.debug('Formatting parsed people.')
                    formatted_people = self.format_parsed_people(parsed_people)
                except Exception as e:
                    log.info(f'Error formatting parsed people: {e}.')
                    go_on=False

            if go_on:
                try:
                    log.debug('Updating people.')
                    self.dict_people = self.update_people(formatted_people)
                except Exception as e:
                    log.info(f'Error updating people: {e}.')
                    go_on=False

            if go_on:
                try:
                    log.debug('Creating people.')
                    self.people = self.create_people(self.dict_people)
                    log.debug('Location update completed successfully.')
                    return True
                except Exception as e:
                    log.info(f'Error converting people: {e}.')

            return False

    def debug_output(self, exception, function, data):
        '''
        Inputs: exception, function name, pertinent data
        Performs: output to debug location of various types of inputs which
                  caused exceptions for troubleshooting.
        '''

        if not self.location_debug.exists():
            self.location_debug.touch(mode=0o660)

        timestamp = datetime.now().strftime('%Y-%m-%d - %H:%M:%S')

        with open(self.location_debug, mode='a') as f:

            f.write('\n\n[{}][{}]:\n'.format(timestamp, function))
            f.write('Exception:\n{}\n'.format(exception))

            if isinstance(data, list):
                f.write('List Data:\n')
                for item in data:
                    f.write(item)

            elif isinstance(data, dict):
                f.write('Dict Data:\n')
                for key, value in data.items():
                    f.write('Key:\n{}\nValue:\n{}\n'.format(key, value))

            else:
                f.write('Data:\n{}\n'.format(data))

            f.write('Raw Output:\n{}\n'.format(self.raw_output))
            for person in self.raw_people:
                f.write('Raw Person:\n{}\n'.format(json.dumps(person, indent=4)))

    def temp_debug(self, raw_dump):
        from pathlib import Path as p
        raw_dump_path = p('/home/hass/.homeassistant/debug/gmaps_raw')
        with raw_dump_path.open('a') as f:
            f.write('raw_output = {}\n'.format(raw_dump))
