from selenium.webdriver.support import expected_conditions as ec
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By

from .localization import Localize
from selenium import webdriver
import chromedriver_binary
from pathlib import Path

import requests
import logging
import pickle
import os

log = logging.getLogger(__name__)

class CookieMonster:

    def __init__(self,  username, password,
                        config_path,
                        cookie_filename,
                        resolution='768x1024',
                        localization='US',
                        debug=False):

        self.browser = None
        self.chrome_options = None
        self.config_path = Path(config_path)
        self.cookie_filename = Path(cookie_filename)
        self.debug = debug
        self.password = password
        self.r = requests.Session()
        self.resolution = resolution
        self.url = Localize(location=localization)
        self.username = username

        self.agent = (  'Mozilla/5.0 (X11; Linux x86_64) \
                        AppleWebKit/537.36 (KHTML, like Gecko) \
                        Chrome/69.0.3497.100 Safari/537.36')
        self.header = { 'User-Agent': self.agent,
                        'Referer': self.url.cookie_header_referer}

        self.r.headers.update(self.header)

    def cookie_check(self):

        cookie = self.config_path / self.cookie_filename

        log.debug('Cookie Check - Opening login URL via requests.')
        self.r.get(self.url.cookie_login_start)

        try:
            log.debug('Cookie Check - Checking if cookie already exists.')
            if cookie.exists():
                cookie = cookie.as_posix()
                log.debug('Cookie Check - Attempting to load cookie from file.')
                with open(cookie, mode='rb') as f:
                    self.r.cookies.update(pickle.load(f))
        except:
            log.debug('Cookie Check - Failed to load cookie file.')
            return False

        # TODO: along with the key check, maybe check the cookie for expiry as well.
        log.debug('Cookie Check - Validating cookie.')
        for key in self.r.cookies.get_dict(domain=self.url.cookie_domain).keys():
            if key in ['1P_JAR', 'APISID', 'CONSENT', 'HSID', 'NID', 'SAPISID', 'SID', 'SIDCC', 'SSID']:
                # not sure if continue is the best method here.
                continue
            else:
                log.debug('Cookie Check - Failed cookie validation.')
                return False

        log.debug('Cookie Check - Cookie exists and is valid.')
        return True

    def init_browser(self):

        log.debug('Driver - Setting up Selenium browser.')
        self.chrome_options = Options()
        self.chrome_options.add_argument('--window-size={}'.format(self.resolution))
        self.chrome_options.set_headless(headless=True)

        log.debug('Driver - Setting Chrome options.')
        self.browser = webdriver.Chrome(chrome_options=self.chrome_options)

    def login(self):

        # TODO: check if debug folder exists. create it if it doesn't. if folder
        # exists, clear previous contents so there's no debug redundency from
        # previous attempts.

        debug_folder = self.config_path / Path('debug')
        url_log = debug_folder / Path('urls.txt')

        if debug_folder.exists() is False:
            debug_folder.mkdir(mode=0o770, parents=False, exist_ok=False)
            url_log.touch(mode=0o660, exist_ok=True)
        else:
            for file in debug_folder.iterdir():
                os.remove(file)
            url_log.touch(mode=0o660, exist_ok=True)

        def debug(ss, url):
            self.browser.save_screenshot('{}/{}'.format(debug_folder.as_posix(), ss))
            with open(url_log.as_posix(), mode='a') as url_output:
                url_output.write('{} URL: {}\n'.format(url, self.browser.current_url))

        log.debug('Login - Opening {}.'.format(self.url.cookie_login_start))
        self.browser.get(self.url.cookie_login_start)

        if self.debug:
            debug('gmail_login_01.png', 'Login Screen')

        log.debug('Login - Entering email.')
        email = self.browser.find_element_by_css_selector('[type=email]')
        email.send_keys(self.username)

        if self.debug:
            debug('gmail_login_02.png', 'Email Submission')

        log.debug('Login - Submitting email.')
        email.send_keys(Keys.RETURN)

        if self.debug:
            debug('gmail_login_03.png', 'Password Screen')

        log.debug('Login - Entering password.')
        password = self.browser.find_element_by_css_selector('[type=password]')
        password.send_keys(self.password)

        if self.debug:
            debug('gmail_login_04.png', 'Password Submission')

        log.debug('Login - Submitting password.')
        password.send_keys(Keys.RETURN)

        if self.debug:
            debug('gmail_login_05.png', '2FA Wait')

        # TODO: could create a login type tree here based on configuration options
        # passed in via configuration.yaml file (notification, authenticator, etc)
        log.debug('Login - Waiting for user to approve login via phone notification...')
        wait = WebDriverWait(self.browser, 10, poll_frequency=1)
        # TODO: the below should be correct for localities which use .com. if
        # this package gains traction, we can have users set their locality in
        # the configuration.yaml file which will translate that locality to the
        # appropriate dict URL which corresponds to the appropriate successful
        # login URL.
        wait.until(ec.url_to_be(self.url.cookie_login_success))

        if self.debug:
            debug('gmail_login_06.png', 'Account Home')

    def export_cookies(self):

        log.debug('Export - Opening {} via requests'.format(self.url.cookie_login_start))
        self.r.get(self.url.cookie_login_start)

        log.debug('Export - Converting selenium cookies to requests.')
        for cookie in self.browser.get_cookies():
            self.r.cookies.set( version=0,
                                name=cookie['name'],
                                value=cookie['value'],
                                domain=cookie.get('domain', None),
                                path=cookie.get('path', '/'),
                                secure=cookie.get('secure', False),
                                expires=cookie.get('expiry', None),
                                discard=False)

        log.debug('Export - Exporting CookieJar via pickle binary.')

        cookie = self.config_path / self.cookie_filename

        with open(cookie.as_posix(), mode='wb') as f:
            pickle.dump(self.r.cookies, f)

        self.browser.quit()

    def run(self):

        log.info('Initiating Cookie Check.')
        if self.cookie_check():
            log.info('Cookie checks out.')
        else:
            log.info('Beginning cookie acquisition.')
            log.info('Initiating Chrome WebDriver.')
            self.init_browser()
            log.info('Initiating Login.')
            self.login()
            log.info('Initiating Cookie Export.')
            self.export_cookies()
