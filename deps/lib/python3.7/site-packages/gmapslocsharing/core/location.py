from cachetools import TTLCache, cached
from datetime import datetime
from random import randint
from time import time
import logging
import brotli
import json
import re

log = logging.getLogger(__name__)

STATE_CACHING_SECONDS = 30
STATE_CACHE = TTLCache(maxsize=1, ttl=STATE_CACHING_SECONDS)

class Location:

    def __init__(self, session, path, config, person, debug):

        self.debug = debug
        self.raw_output = None
        self.raw_people = None
        self.new_people = {}
        self.old_people = {}
        self.person_class = person
        self.people = []
        self.session = session
        self.config = config

        self.debug_folder = path / 'debug'
        self.debug_file = self.debug_folder / 'raw_output_debug'

        self.headers = {'authority': self.config['header_authority'],
                        'accept-language': 'en-US,en;q=0.9',
                        'accept-encoding': 'gzip, deflate, br',
                        'accept': 'application/json, text/plain, */*',
                        'referer': self.config['header_referer'],
                        'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3626.121 Safari/537.36'}
        self.payload = {'authuser': 1,
                        'hl': 'en',
                        'gl': 'us',
                        'authuser': 1,
                        'pb': '!1e1!2m2!1sp-PDW8CZOKj_0gKPorqABQ!7e81!3m2!1s107699590211062977112!2s'}

        self.debug_file.touch(mode=0o660)

    def query_data(self):

        try:
            log.debug('Query - Requesting location data.')
            response = self.session.get(self.config['sharing_url'], params=self.payload, headers=self.headers)
            log.debug('Query - Decompressing and decoding response.')
            self.raw_output = brotli.decompress(response.content).decode('utf-8')
            return True
        except Exception as e:
            log.error('Query Failed - {}'.format(e))
            if self.debug:
                self.debug_output(e, 'query_data', 'N/A')
            return False

    def parse_raw_output(self):
        '''
        Input: raw output from gmapslocsharing query.
        Performs: only keep useful rows. create dict for each user. with key:value
        Returns: list of user dictionaries
        '''

        raw_output = self.raw_output.split('[[')[2:]
        keep_rows = [1, 3, 5, 8, 9, 11, 22]
        ro_dict = { 1:'id',3:'photo',5:'full_name',8:'gps',
                    9:'address',11:'country',22:'battery'}
        raw_people = []

        for person in raw_output:
            raw_person = {}
            for i, p in enumerate(person.split('"'), 0):
                if i in keep_rows:
                    key = ro_dict[i]
                    raw_person[key] = p
            raw_people.append(raw_person)
        if len(raw_people) > 0:
            self.raw_people = raw_people
            return True
        return False

    def parse_raw_people(self):

        re_gps = re.compile('([-0-9]+.[0-9]+),([-0-9]+.[0-9]+)],([0-9]+),([0-9]+)')
        re_battery = re.compile('^.*\[([0-1]{1}),([0-9]{1,3})')

        new_people = {}
        for person in self.raw_people:
            id = person['id']
            name = person['full_name'].split()[0]
            new_people[id] = {'gps':{}, 'battery':{}}
            for key, value in person.items():
                value = value.replace('\n', '')
                if key == 'id':
                    log.debug('Setting {} for {}.'.format(key, name))
                    new_people[id][key] = int(value)
                elif key == 'photo':
                    log.debug('Setting {} for {}.'.format(key, name))
                    new_people[id][key] = value
                elif key == 'full_name':
                    log.debug('Setting {} for {}.'.format(key, name))
                    new_people[id][key] = value
                    new_people[id]['first_name'] = value.split()[0]
                elif key == 'gps':
                    try:
                        log.debug('Setting lat, lon, accuracy, and last seen for {}.'.format(name))
                        gps = re_gps.search(value).group(1,2,3,4)
                        new_people[id][key]['latitude'] = gps[1]
                        new_people[id][key]['longitude'] = gps[0]
                        new_people[id][key]['accuracy'] = int(gps[3])
                        new_people[id]['last_seen'] = int(gps[2]) / 1000
                    except Exception as e:
                        log.error('Bad or missing {} data for {}.'.format(key, name))
                        if self.debug:
                            log.debug('Dumping raw_people data to debug folder.')
                            self.debug_output(e, 'parse_raw_people', value)
                        log.error('Using dummy {} data for {}.'.format(key, name))
                        # Set latitude & longitude to None
                        # Set accuracy outside default ignore range
                        new_people[id][key]['latitude'] = None
                        new_people[id][key]['longitude'] = None
                        new_people[id][key]['accuracy'] = None
                        new_people[id]['last_seen'] = time()
                elif key == 'address':
                    if ' ' in value:
                        try:
                            log.debug('Setting {} for {}.'.format(key, name))
                            new_people[id][key] = value
                        except Exception as e:
                            log.error('Bad or missing {} data for {}.'.format(key, name))
                            if self.debug:
                                self.debug_output('', 'parse_raw_people', value)
                            log.error('Using dummy {} data for {}.'.format(key, name))
                            new_people[id][key] = None
                elif key == 'country':
                    if value.isalpha() and value.isupper():
                        log.debug('Setting {} for {}.'.format(key, name))
                        new_people[id][key] = value
                    else:
                        log.error('Bad or missing {} data for {}.'.format(key, name))
                        log.error('Using dummy {} data for {}.'.format(key, name))
                        new_people[id][key] = None
                elif key == 'battery':
                    try:
                        log.debug('Setting {} for {}.'.format(key, name))
                        battery = re_battery.search(value).group(1,2)
                        new_people[id][key]['charging'] = True if battery[0] == 1 else False
                        new_people[id][key]['level'] = int(battery[1])
                    except:
                        log.error('Bad or missing {} data for {}.'.format(key, name))
                        log.error('Using dummy {} data for {}.'.format(key, name))
                        new_people[id][key]['charging'] = False
                        new_people[id][key]['level'] = None
        if len(new_people.keys()) > 0:
            self.new_people = new_people
            return True
        return False

    def update_people(self):

        np = self.new_people
        op = self.old_people if len(self.old_people.keys()) > 0 else {}

        if len(op.keys()) == 0:
            log.debug('Copying new_people to old_people on first run.')
            op = np
        else:
            if np.keys() != op.keys():
                add = [id for id in np.keys() if len(np.keys()) > 0 and id not in op.keys()]
                remove = [id for id in op.keys() if len(op.keys()) > 0 and id not in np.keys()]
                if len(add) != 0:
                    log.debug('IDs to add: {}'.format(add))
                if len(remove) != 0:
                    log.debug('IDs to remove: {}'.format(remove))
                for id in add:
                    log.debug('Adding {}:{} to old_people.'.format(id, np[id]))
                    op[id] = np[id]
                for id in remove:
                    log.debug('Deleting {}:{} from old_people.'.format(id, op[id]))
                    del op[id]

            if np.keys() == op.keys():
                log.debug('Comparing new and existing persons.')
                for id, person in np.items():
                    name = person['full_name'].split()[0]
                    for key, value in person.items():
                        if not isinstance(value, dict):
                            new_value = np[id][key]
                            old_value = op[id][key]
                            if new_value != old_value and new_value is not None:
                                log.debug('Updating {} for {} to {}.'.format(key, name, new_value))
                                op[id][key] = np[id][key]
                        elif isinstance(value, dict):
                            for k, v in value.items():
                                nv = np[id][key][k]
                                ov = op[id][key][k]
                                if nv != ov and nv is not None:
                                    log.debug('Updating {}:{} for {} to {}.'.format(key, k, name, nv))
                                    op[id][key][k] = np[id][key][k]
        if len(op.keys()) > 0:
            self.old_people = op
            return True
        return False

    def create_people(self):

        try:
            Person = self.person_class
            people = self.old_people

            log.debug('Create People - Converting location data into Person object.')
            for id, person in people.items():
                self.people.append(Person(person))

            log.debug('Create People - Created {} people.'.format(len(self.people)))
            return True

        except Exception as e:
            log.error('Create People Failed - {}'.format(e))

        return False

    # TODO: should probably modify cache duration based on refresh interval
    # from configuration.yaml. consideration would be if ttl is shorter than
    # refresh interval possibly? need to dig into this functionality a bit more
    # to determine best course of action.
    @cached(STATE_CACHE)
    def update(self):

        log.debug('Updating location sharing data.')

        self.raw_output = None
        self.raw_people = None
        self.new_people = None
        self.people = []

        try:
            log.debug('Requesting data via browser.')
            if self.query_data():
                log.debug('Parsing raw output.')
                if self.parse_raw_output():
                    log.debug('Parsing raw people.')
                    if self.parse_raw_people():
                        log.debug('Updating people.')
                        if self.update_people():
                            log.debug('Converting people to Person objects.')
                            if self.create_people():
                                log.debug('Location update completed successfully.')

        except Exception as e:
            log.error('Update Failure - {}'.format(e))

    def debug_output(self, exception, origin, data):

        timestamp = datetime.now().strftime('%Y-%m-%d - %H:%M:%S')

        with open(self.debug_file, mode='a') as f:
            f.write('\n\n[{}][{}]:\n\n'.format(timestamp, origin))
            if isinstance(data, list):
                for item in data:
                    if isinstance(item, dict):
                        for key, value in item.items():
                            f.write('Exception: {}\nKey: {} | Value: {}\n'.format(exception, key, value))
                    else:
                        f.write('Exception: {}\nItem: {}\n'.format(exception, item))
            else:
                f.write('Exception: {}\nData: {}\n'.format(exception, data))
